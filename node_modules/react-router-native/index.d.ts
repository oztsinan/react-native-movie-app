import * as React from "react";
import { GestureResponderEvent, TouchableHighlightProps } from "react-native";
import { MemoryRouter, MemoryRouterProps, Navigate, NavigateOptions, Outlet, Route, Router, Routes, createRoutesFromChildren, generatePath, matchRoutes, matchPath, createPath, parsePath, resolvePath, renderMatches, useHref, useInRouterContext, useLocation, useMatch, useNavigate, useNavigationType, useOutlet, useParams, useResolvedPath, useRoutes, useOutletContext } from "react-router";
import type { To } from "react-router";
import URLSearchParams from "@ungap/url-search-params";
export { MemoryRouter, Navigate, Outlet, Route, Router, Routes, createRoutesFromChildren, generatePath, matchRoutes, matchPath, createPath, parsePath, resolvePath, renderMatches, useHref, useInRouterContext, useLocation, useMatch, useNavigate, useNavigationType, useOutlet, useParams, useResolvedPath, useRoutes, useOutletContext, };
export { NavigationType } from "react-router";
export type { Hash, IndexRouteProps, LayoutRouteProps, Location, MemoryRouterProps, NavigateFunction, NavigateOptions, NavigateProps, Navigator, OutletProps, Params, Path, PathMatch, PathRouteProps, RouteMatch, RouteObject, RouteProps, RouterProps, RoutesProps, Pathname, Search, To, } from "react-router";
/** @internal */
export { UNSAFE_NavigationContext, UNSAFE_LocationContext, UNSAFE_RouteContext, } from "react-router";
export interface NativeRouterProps extends MemoryRouterProps {
}
/**
 * A <Router> that runs on React Native.
 */
export declare function NativeRouter(props: NativeRouterProps): JSX.Element;
export interface LinkProps extends TouchableHighlightProps {
    children?: React.ReactNode;
    onPress?: (event: GestureResponderEvent) => void;
    replace?: boolean;
    state?: any;
    to: To;
}
/**
 * A <TouchableHighlight> that navigates to a different URL when touched.
 */
export declare function Link({ onPress, replace, state, to, ...rest }: LinkProps): JSX.Element;
/**
 * Handles the press behavior for router `<Link>` components. This is useful if
 * you need to create custom `<Link>` components with the same press behavior we
 * use in our exported `<Link>`.
 */
export declare function useLinkPressHandler(to: To, { replace, state, }?: {
    replace?: boolean;
    state?: any;
}): (event: GestureResponderEvent) => void;
/**
 * Enables support for the hardware back button on Android.
 */
export declare function useHardwareBackButton(): void;
export { useHardwareBackButton as useAndroidBackButton };
/**
 * Enables deep linking, both on the initial app launch and for
 * subsequent incoming links.
 */
export declare function useDeepLinking(): void;
/**
 * A convenient wrapper for accessing individual query parameters via the
 * URLSearchParams interface.
 */
export declare function useSearchParams(defaultInit?: URLSearchParamsInit): [URLSearchParams, SetURLSearchParams];
declare type SetURLSearchParams = (nextInit?: URLSearchParamsInit | undefined, navigateOpts?: NavigateOptions | undefined) => void;
export declare type ParamKeyValuePair = [string, string];
export declare type URLSearchParamsInit = string | ParamKeyValuePair[] | Record<string, string | string[]> | URLSearchParams;
/**
 * Creates a URLSearchParams object using the given initializer.
 *
 * This is identical to `new URLSearchParams(init)` except it also
 * supports arrays as values in the object form of the initializer
 * instead of just strings. This is convenient when you need multiple
 * values for a given key, but don't want to use an array initializer.
 *
 * For example, instead of:
 *
 *   let searchParams = new URLSearchParams([
 *     ['sort', 'name'],
 *     ['sort', 'price']
 *   ]);
 *
 * you can do:
 *
 *   let searchParams = createSearchParams({
 *     sort: ['name', 'price']
 *   });
 */
export declare function createSearchParams(init?: URLSearchParamsInit): URLSearchParams;
